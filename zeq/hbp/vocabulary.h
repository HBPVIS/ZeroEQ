
/* Copyright (c) 2014-2015, Human Brain Project
 *                          Daniel Nachbaur <daniel.nachbaur@epfl.ch>
 *                          Juan Hernando <jhernando@fi.upm.es>
 *                          Grigori Chevtchenko <grigori.chevtchenko@epfl.ch>
 */

#ifndef ZEQ_HBP_VOCABULARY_H
#define ZEQ_HBP_VOCABULARY_H

#include <zeq/types.h>
#include <zeq/api.h>

#include <zeq/hbp/enums.h>

#include <zeq/hbp/camera_zeq_generated.h>
#include <zeq/hbp/cellSetBinaryOp_zeq_generated.h>
#include <zeq/hbp/frame_zeq_generated.h>
#include <zeq/hbp/imageJPEG_zeq_generated.h>
#include <zeq/hbp/lookupTable1D_zeq_generated.h>
#include <zeq/hbp/selections_zeq_generated.h>

namespace zeq
{
namespace hbp
{

typedef std::vector< uint32_t > uint32_ts;

namespace data
{

/** Rendering frame information. */
struct Frame
{
    Frame() : start(0), current(0), end( 0xFFFFFFFFu ), delta(0) {}
    Frame( const uint32_t s, const uint32_t c, const uint32_t e, const int d )
        : start(s), current(c), end(e), delta(d) {}
    bool operator == ( const zeq::hbp::data::Frame& rhs ) const
    {
        return start == rhs.start && current == rhs.current &&
               end == rhs.end && delta == rhs.delta;
    }

    uint32_t start;
    uint32_t current;
    uint32_t end;
    int delta;
};

inline std::ostream& operator << ( std::ostream& os, const Frame& f )
{
    return os << f.start << ", " << f.current << ", " << f.end << ", "
              << f.delta;
}


/**
 * Holds informations about JPEG images.
 *
 * It has the size infomations and the image data, data is a pointer
 * to avoid copy. The data pointer is only valid as long as the zeq Event
 * or rendering resource internal event with image data stays alive.
 */
struct ImageJPEG
{
    ImageJPEG( const uint32_t sizeInBytes, const uint8_t* data )
        : _sizeInBytes( sizeInBytes )
        , _data( data )
    {}
    uint32_t getSizeInBytes() const { return _sizeInBytes; }
    const uint8_t* getDataPtr() const { return _data; }

private:
    const uint32_t _sizeInBytes;
    const uint8_t* _data;
};


/**
 * Stores two unsigned int vectors and an operation flag.
 *
 * This class stores a couple of unsigned int vectors
 * and an operation flag indicating the operation type of the event.
 *
 */
struct CellSetBinaryOp
{
public:

    CellSetBinaryOp() {}
    CellSetBinaryOp( const uint32_ts& first_, const uint32_ts& second_,
                     CellSetBinaryOpType operation_ )
        : first( first_ )
        , second( second_ )
        , operation( operation_ )
    {}

    uint32_ts first;
    uint32_ts second;
    CellSetBinaryOpType operation;
};

}

/**
 * Serialize the given camera matrix into an Event of type EVENT_CAMERA.
 *
 * The matrix to be serialized and sent to other instances is the one
 * used in the application to transform from world coordinate space into
 * camera space. Microns are assumed as unit and it has the BBP circuit
 * as reference.
 * @param matrix the 4x4 camera matrix in OpenGL data layout.
 * @return the serialized event.
 */
ZEQ_API Event serializeCamera( const std::vector< float >& matrix );

/**
 * Deserialize the given camera event into the 4x4 matrix.
 *
 * The matrix received and deserialized is the one used in the application
 * to transform from world coordinate space into camera space.
 * Microns are assumed as unit and it has the BBP circuit as reference.
 * @param camera the camera event generated by serializeCamera().
 * @return the 4x4 camera matrix in OpenGL data layout.
 */
ZEQ_API std::vector< float > deserializeCamera( const Event& event );

/**
 * Serialize the given frame specification
 *
 * If the application supports animation, it will start looping from the current
 * frame, between start and end. Otherwise it will display the current
 * frame. Serialization will enforce start<=current<=end.
 *
 * @param frame the frame specification (start, current, end).
 * @return the serialized event.
 */
ZEQ_API Event serializeFrame( const data::Frame& frame );

/** Deserialize the given frame event into */
ZEQ_API data::Frame deserializeFrame( const Event& event );

/**
 * Serialize the given neuron selection into an Event of type
 * EVENT_SELECTED_IDS.
 * @param selection vector of neuron GIDs (uint).
 * @return the serialized event.
 */
ZEQ_API
Event serializeSelectedIDs( const uint32_ts& ids );

/**
 * Deserialize the given neuron selection event into the vector of neuron GIDs.
 * @param event a selection event generated by serializeSelection().
 * @return the vector of neuron GIDs (uint).
 */
ZEQ_API
std::vector< unsigned int > deserializeSelectedIDs( const Event& event );

/**
 * Serialize the given selection into an Event of type EVENT_TOGGLE_ID_REQUEST.
 * @param ids vector of neuron GIDs (uint).
 * @return the serialized event.
 */
ZEQ_API
Event serializeToggleIDRequest( const uint32_ts& ids );

/**
 * Deserialize an toggle selection request event into the vector of neuron GIDs.
 * @param event an event generated by serializeToggleIDRequest().
 * @return the vector of neuron GIDs (uint).
 */
ZEQ_API
std::vector< unsigned int > deserializeToggleIDRequest( const Event& event );

/**
 * Serialize the given lookup table into an Event of type EVENT_LOOKUPTABLE1D.
 * The lookup table consists of 4 times 256 bytes, interleaved in r,g,b,a
 * layout. It is used to map intensity values onto a color, e.g., in direct
 * volume rendering.
 * @param lut the 1024 byte lookup table.
 * @return the serialized event.
 */
ZEQ_API Event serializeLookupTable1D( const std::vector< uint8_t >& lut );

/**
 * Deserialize the given 1D lookup table.
 * @param camera the camera event generated by serializeCamera().
 * @return the 1024 byte lookup table
 * @sa serializeLookupTable1D()
 */
ZEQ_API std::vector< uint8_t > deserializeLookupTable1D( const Event& event );

/**
 * Serialize the given JPEG image into an Event of type EVENT_IMAGEJPEG.
 * @param image the JPEG image.
 * @return the serialized event.
 */
ZEQ_API Event serializeImageJPEG( const data::ImageJPEG& image );

/**
 * Deserialize the given EVENT_IMAGEJPEG event into an JPEG image.
 * @param event the zeq EVENT_IMAGEJPEG.
 * @return the jpeg image.
 */
ZEQ_API data::ImageJPEG deserializeImageJPEG( const Event& event );

/**
 * Serialize the given CellSetBinaryOp into an Event of type
 * EVENT_CELLSETBINARYOP.
 * @param cellSetBinaryOp the CellSetBinaryOp to be serialized.
 * @return the serialized event.
 */
ZEQ_API
Event serializeCellSetBinaryOp( const data::CellSetBinaryOp& cellSetBinaryOp );

/**
 * Convenience overload of the function above
 */
ZEQ_API
Event serializeCellSetBinaryOp( const uint32_ts& first, const uint32_ts& second,
                                CellSetBinaryOpType type );

/**
 * Deserialize the given EVENT_CELLSETBINARYOP event into a CellSetBinaryOp
 * consisting of a couple of std::vector of unsigned int and the operation type.
 * @param event the event product of serializeCellSetBinaryOp.
 * @return the deserialized CellSetBinaryOp.
 */
ZEQ_API data::CellSetBinaryOp deserializeCellSetBinaryOp( const Event& event );

}
}
#endif
